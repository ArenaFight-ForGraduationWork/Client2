#include "stdafx.h"
#include "Player.h"



CPlayer::CPlayer()
{
	m_pObject = nullptr;

	m_fSpeed = 100;
}

CPlayer::~CPlayer()
{
	m_pObject = nullptr;
}

void CPlayer::SetObject(CGameObject *pObject)
{
	m_pObject = pObject;
}
void CPlayer::ReleaseObject()
{
	m_pObject = nullptr;
}

void CPlayer::Move(const float fTheta, const DWORD dwDirection, const float fTimeElapsed)
{
	// 1) 카메라와 같은 방향을 보도록 회전
	float fYaw = 360 - (fTheta + 90);
	m_pObject->Rotate(&D3DXVECTOR3(0,1,0), fYaw);
	//m_pObject->RotateAbsolute(&d3dxvDirection);

	// 2) 입력받은 방향에 따라 해당 방향으로 회전
	D3DXVECTOR3 d3dxvRight, d3dxvUp, d3dxvLookAt;
	d3dxvLookAt = D3DXVECTOR3(0, 0, 0);
	if (dwDirection)	// 이동해야할 방향 = LookAt벡터
	{
		if (dwDirection & DIR_FORWARD)	d3dxvLookAt += (m_pObject->GetLookAt());
		if (dwDirection & DIR_BACKWARD)	d3dxvLookAt -= (m_pObject->GetLookAt());
		if (dwDirection & DIR_LEFT)		d3dxvLookAt -= (m_pObject->GetRight());
		if (dwDirection & DIR_RIGHT)	d3dxvLookAt += (m_pObject->GetRight());
		//if (dwDirection & DIR_FORWARD)	d3dxvLookAt += *(m_pObject->GetLookAt());
		//if (dwDirection & DIR_BACKWARD)	d3dxvLookAt -= *(m_pObject->GetLookAt());
		//if (dwDirection & DIR_LEFT)		d3dxvLookAt -= *(m_pObject->GetRight());
		//if (dwDirection & DIR_RIGHT)		d3dxvLookAt += *(m_pObject->GetRight());
	}
	d3dxvUp = D3DXVECTOR3(0, 1, 0);
	D3DXVec3Cross(&d3dxvRight, &d3dxvUp, &d3dxvLookAt);	// Right벡터는 Up벡터와 LookAt벡터를 외적하여 계산
	D3DXVec3Normalize(&d3dxvRight, &d3dxvRight);

	//m_pObject->Rotate(*d3dxvLookAt);
	//m_pObject->RotateAbsolute(&d3dxvRight, &d3dxvUp, &d3dxvLookAt);

	// 3) 로컬 z축으로 속도 * 시간만큼 이동
	m_pObject->MoveForward(m_fSpeed * fTimeElapsed);
}

////void CPlayer::Move(const D3DXVECTOR3 *pCameraPitchYawRoll, const DWORD dwDirection, const float fTimeElapsed)
//void CPlayer::Move(const D3DXVECTOR3 *pd3dxvCameraRightVector, const DWORD dwDirection, const float fTimeElapsed)
//{
//	// 1) 카메라와 같은 방향을 보도록 회전
//	//D3DXVECTOR3 d3dxvDirection = D3DXVECTOR3(0, pCameraPitchYawRoll->y, 0);
//	D3DXVECTOR3 d3dxvRight = *pd3dxvCameraRightVector;
//	D3DXVec3Normalize(&d3dxvRight, &d3dxvRight);
//	D3DXVECTOR3 d3dxvUp = D3DXVECTOR3(0, 1, 0);
//	D3DXVECTOR3 d3dxvLookAt;
//	D3DXVec3Cross(&d3dxvLookAt, &d3dxvRight, &d3dxvUp);
//
//	///* 6) Right, Up, Look벡터와 Position벡터로 변환행렬 생성 */
//	//m_pd3dxmtxView->_11 = m_pd3dxvRight->x;
//	//m_pd3dxmtxView->_12 = m_pd3dxvUp->x;
//	//m_pd3dxmtxView->_13 = m_pd3dxvLook->x;
//	//m_pd3dxmtxView->_21 = m_pd3dxvRight->y;
//	//m_pd3dxmtxView->_22 = m_pd3dxvUp->y;
//	//m_pd3dxmtxView->_23 = m_pd3dxvLook->y;
//	//m_pd3dxmtxView->_31 = m_pd3dxvRight->z;
//	//m_pd3dxmtxView->_32 = m_pd3dxvUp->z;
//	//m_pd3dxmtxView->_33 = m_pd3dxvLook->z;
//	//m_pd3dxmtxView->_41 = -D3DXVec3Dot(m_pd3dxvPosition, m_pd3dxvRight);
//	//m_pd3dxmtxView->_42 = -D3DXVec3Dot(m_pd3dxvPosition, m_pd3dxvUp);
//	//m_pd3dxmtxView->_43 = -D3DXVec3Dot(m_pd3dxvPosition, m_pd3dxvLook);
//
//
//
//	m_pObject->Rotate(*d3dxvDirection);
//	//m_pObject->RotateAbsolute(&d3dxvDirection);
//
//	// 2) 입력받은 방향에 따라 해당 방향으로 회전
//	D3DXVECTOR3 d3dxvRight, d3dxvUp, d3dxvLookAt;
//	d3dxvLookAt = D3DXVECTOR3(0, 0, 0);
//	if (dwDirection)	// 이동해야할 방향 = LookAt벡터
//	{
//		if (dwDirection & DIR_FORWARD)	d3dxvLookAt += (m_pObject->GetLookAt());
//		if (dwDirection & DIR_BACKWARD)	d3dxvLookAt -= (m_pObject->GetLookAt());
//		if (dwDirection & DIR_LEFT)		d3dxvLookAt -= (m_pObject->GetRight());
//		if (dwDirection & DIR_RIGHT)	d3dxvLookAt += (m_pObject->GetRight());
//		//if (dwDirection & DIR_FORWARD)	d3dxvLookAt += *(m_pObject->GetLookAt());
//		//if (dwDirection & DIR_BACKWARD)	d3dxvLookAt -= *(m_pObject->GetLookAt());
//		//if (dwDirection & DIR_LEFT)		d3dxvLookAt -= *(m_pObject->GetRight());
//		//if (dwDirection & DIR_RIGHT)		d3dxvLookAt += *(m_pObject->GetRight());
//	}
//	d3dxvUp = D3DXVECTOR3(0, 1, 0);
//	D3DXVec3Cross(&d3dxvRight, &d3dxvUp, &d3dxvLookAt);	// Right벡터는 Up벡터와 LookAt벡터를 외적하여 계산
//	D3DXVec3Normalize(&d3dxvRight, &d3dxvRight);
//
//	m_pObject->Rotate(*d3dxvDirection);
//	//m_pObject->RotateAbsolute(&d3dxvRight, &d3dxvUp, &d3dxvLookAt);
//
//	// 3) 로컬 z축으로 속도 * 시간만큼 이동
//	m_pObject->MoveForward(m_fSpeed * fTimeElapsed);
//}

//void CPlayer::MoveRelative(const float x, const float y, const float z)
//{
//	if (m_pObject)
//		m_pObject->MoveForward(z);
//		//m_pObject->MoveRelative(x, y, z);
//}
//void CPlayer::MoveRelative(const D3DXVECTOR3 *vec)
//{
//	if (m_pObject)
//		m_pObject->MoveForward(vec->z);
//	//m_pObject->MoveRelative(vec);
//}
//void CPlayer::MoveAbsolute(const float x, const float y, const float z)
//{
//	if (m_pObject)
//		m_pObject->MoveForward(z)
//		//m_pObject->MoveAbsolute(x, y, z);
//}
//void CPlayer::MoveAbsolute(const D3DXVECTOR3 *vec)
//{
//	if (m_pObject)
//		m_pObject->MoveAbsolute(vec);
//}
//
//void CPlayer::RotateRelative(const float x, const float y, const float z)
//{
//	if (m_pObject)
//		m_pObject->RotateRelative(x, y, z);
//}
//void CPlayer::RotateRelative(const D3DXVECTOR3 *vec)
//{
//	if (m_pObject)
//		m_pObject->RotateRelative(vec);
//}
//void CPlayer::RotateAbsolute(const float x, const float y, const float z)
//{
//	if (m_pObject)
//		m_pObject->RotateAbsolute(x, y, z);
//}
//void CPlayer::RotateAbsolute(const D3DXVECTOR3 *vec)
//{
//	if (m_pObject)
//		m_pObject->RotateAbsolute(vec);
//}

const D3DXVECTOR3* CPlayer::GetPosition()
{
	// 오브젝트가 있으면 해당 오브젝트의 위치를 반환하고, 없으면 원점을 반환한다
	if (m_pObject)
	{
		return &(m_pObject->GetPosition());
	}

	return &D3DXVECTOR3(0, 0, 0);
}




//CPlayer::CPlayer()
//{
//	//m_pCamera = NULL;
//
//	m_d3dxvPosition = D3DXVECTOR3(0.0f, 0.0f, 0.0f);
//	m_d3dxvRight = D3DXVECTOR3(1.0f, 0.0f, 0.0f);
//	m_d3dxvUp = D3DXVECTOR3(0.0f, 1.0f, 0.0f);
//	m_d3dxvLook = D3DXVECTOR3(0.0f, 0.0f, 1.0f);
//
//	m_d3dxvVelocity = D3DXVECTOR3(0.0f, 0.0f, 0.0f);
//	m_d3dxvGravity = D3DXVECTOR3(0.0f, 0.0f, 0.0f);
//	m_fMaxVelocityXZ = 0.0f;
//	m_fMaxVelocityY = 0.0f;
//	m_fFriction = 0.0f;
//
//	m_fPitch = 0.0f;
//	m_fRoll = 0.0f;
//	m_fYaw = 0.0f;
//
//	m_pPlayerUpdatedContext = NULL;
//	m_pCameraUpdatedContext = NULL;
//
//	m_pShader = NULL;
//}
//
//CPlayer::~CPlayer()
//{
//	//if (m_pCamera) delete m_pCamera;
//}
//
//void CPlayer::CreateShaderVariables(ID3D11Device *pd3dDevice)
//{
//}
//
//void CPlayer::UpdateShaderVariables(ID3D11DeviceContext *pd3dDeviceContext)
//{
//	////플레이어의 현재 카메라의 UpdateShaderVariables() 멤버 함수를 호출한다.
//	//if (m_pCamera) m_pCamera->UpdateShaderVariables(pd3dDeviceContext);
//}
//
///*플레이어의 위치와 회전축으로부터 월드 변환 행렬을 생성하는 함수이다. 플레이어의 Right 벡터가 월드 변환 행렬의 첫 번째 행 벡터, Up 벡터가 두 번째 행 벡터, Look 벡터가 세 번째 행 벡터, 플레이어의 위치 벡터가 네 번째 행 벡터가 된다.*/
//void CPlayer::RegenerateWorldMatrix()
//{
//	m_d3dxmtxWorld._11 = m_d3dxvRight.x;
//	m_d3dxmtxWorld._12 = m_d3dxvRight.y;
//	m_d3dxmtxWorld._13 = m_d3dxvRight.z;
//	m_d3dxmtxWorld._21 = m_d3dxvUp.x;
//	m_d3dxmtxWorld._22 = m_d3dxvUp.y;
//	m_d3dxmtxWorld._23 = m_d3dxvUp.z;
//	m_d3dxmtxWorld._31 = m_d3dxvLook.x;
//	m_d3dxmtxWorld._32 = m_d3dxvLook.y;
//	m_d3dxmtxWorld._33 = m_d3dxvLook.z;
//	m_d3dxmtxWorld._41 = m_d3dxvPosition.x;
//	m_d3dxmtxWorld._42 = m_d3dxvPosition.y;
//	m_d3dxmtxWorld._43 = m_d3dxvPosition.z;
//}
//
///*플레이어의 위치를 변경하는 함수이다. 플레이어의 위치는 기본적으로 사용자가 플레이어를 이동하기 위한 키보드를 누를 때 변경된다. 플레이어의 이동 방향(dwDirection)에 따라 플레이어를 fDistance 만큼 이동한다.*/
//void CPlayer::Move(DWORD dwDirection, float fDistance, bool bUpdateVelocity)
//{
//	if (dwDirection)
//	{
//		D3DXVECTOR3 d3dxvShift = D3DXVECTOR3(0, 0, 0);
//		//화살표 키 ‘↑’를 누르면 로컬 z-축 방향으로 이동(전진)한다. ‘↓’를 누르면 반대 방향으로 이동한다.
//		if (dwDirection & DIR_FORWARD) d3dxvShift += m_d3dxvLook * fDistance;
//		if (dwDirection & DIR_BACKWARD) d3dxvShift -= m_d3dxvLook * fDistance;
//		//화살표 키 ‘→’를 누르면 로컬 x-축 방향으로 이동한다. ‘←’를 누르면 반대 방향으로 이동한다.
//		if (dwDirection & DIR_RIGHT) d3dxvShift += m_d3dxvRight * fDistance;
//		if (dwDirection & DIR_LEFT) d3dxvShift -= m_d3dxvRight * fDistance;
//		//‘Page Up’을 누르면 로컬 y-축 방향으로 이동한다. ‘Page Down’을 누르면 반대 방향으로 이동한다.
//		if (dwDirection & DIR_UP) d3dxvShift += m_d3dxvUp * fDistance;
//		if (dwDirection & DIR_DOWN) d3dxvShift -= m_d3dxvUp * fDistance;
//
//		//플레이어를 현재 위치 벡터에서 d3dxvShift 벡터 만큼 이동한다.
//		Move(d3dxvShift, bUpdateVelocity);
//	}
//}
//
//void CPlayer::Move(const D3DXVECTOR3& d3dxvShift, bool bUpdateVelocity)
//{
//	//bUpdateVelocity가 참이면 플레이어를 이동하지 않고 속도 벡터를 변경한다.
//	if (bUpdateVelocity)
//	{
//		m_d3dxvVelocity += d3dxvShift;
//	}
//	else
//	{
//		//플레이어를 현재 위치 벡터에서 d3dxvShift 벡터 만큼 이동한다.
//		D3DXVECTOR3 d3dxvPosition = m_d3dxvPosition + d3dxvShift;
//		m_d3dxvPosition = d3dxvPosition;
//		RegenerateWorldMatrix();
//		////플레이어의 위치가 변경되었으므로 카메라의 위치도 d3dxvShift 벡터 만큼 이동한다.
//		//m_pCamera->Move(d3dxvShift);
//	}
//}
//
////플레이어를 로컬 x-축, y-축, z-축을 중심으로 회전한다.
//void CPlayer::Rotate(float x, float y, float z)
//{
//	D3DXMATRIX mtxRotate;
//	//DWORD nCurrentCameraMode = m_pCamera->GetMode();
//
//	////1인칭 카메라 또는 3인칭 카메라의 경우 플레이어의 회전은 약간의 제약이 따른다.
//	//if ((nCurrentCameraMode == THIRD_PERSON_CAMERA))
//	//{
//	//	// 로컬 x-축을 중심으로 회전하는 것은 고개를 앞뒤로 숙이는 동작에 해당한다. 
//	//	if (x != 0.0f)
//	//	{
//	//		m_fPitch += x;
//	//		if (m_fPitch > +89.0f) { x -= (m_fPitch - 89.0f); m_fPitch = +89.0f; }
//	//		if (m_fPitch < -89.0f) { x -= (m_fPitch + 89.0f); m_fPitch = -89.0f; }
//	//	}
//	//	//로컬 y-축을 중심으로 회전하는 것은 몸통을 돌리는 것이므로 회전 각도의 제한이 없다.
//	//	if (y != 0.0f)
//	//	{
//	//		m_fYaw += y;
//	//		if (m_fYaw > 360.0f) m_fYaw -= 360.0f;
//	//		if (m_fYaw < 0.0f) m_fYaw += 360.0f;
//	//	}
//	//	// 로컬 z-축을 중심으로 회전하는 것은 몸통을 좌우로 기울이는 것
//	//	if (z != 0.0f)
//	//	{
//	//		m_fRoll += z;
//	//		if (m_fRoll > +20.0f) { z -= (m_fRoll - 20.0f); m_fRoll = +20.0f; }
//	//		if (m_fRoll < -20.0f) { z -= (m_fRoll + 20.0f); m_fRoll = -20.0f; }
//	//	}
//	//	//카메라를 x, y, z 만큼 회전한다. 플레이어를 회전하면 카메라가 회전하게 된다.
//	//	m_pCamera->Rotate(x, y, z);
//
//	//	// 플레이어를 회전한다. 1인칭 카메라 또는 3인칭 카메라에서 플레이어의 회전은 로컬 y-축에서만 일어난다.
//	//	// 플레이어의 로컬 y-축(Up 벡터)을 기준으로 로컬 z-축(Look 벡터)와 로컬 x-축(Right 벡터)을 회전시킨다.
//	//	// 기본적으로 Up 벡터를 기준으로 회전하는 것은 플레이어가 똑바로 서있는 것을 가정한다는 의미이다.
//	//	if (y != 0.0f)
//	//	{
//	//		D3DXMatrixRotationAxis(&mtxRotate, &m_d3dxvUp, (float)D3DXToRadian(y));
//	//		D3DXVec3TransformNormal(&m_d3dxvLook, &m_d3dxvLook, &mtxRotate);
//	//		D3DXVec3TransformNormal(&m_d3dxvRight, &m_d3dxvRight, &mtxRotate);
//	//	}
//	//}
//
//	// 회전으로 인해 플레이어의 로컬 x-축, y-축, z-축이 서로 직교하지 않을 수 있으므로
//	// z-축(LookAt 벡터)을 기준으로 하여 서로 직교하고 단위벡터가 되도록 한다.
//	D3DXVec3Normalize(&m_d3dxvLook, &m_d3dxvLook);
//	D3DXVec3Cross(&m_d3dxvRight, &m_d3dxvUp, &m_d3dxvLook);
//	D3DXVec3Normalize(&m_d3dxvRight, &m_d3dxvRight);
//	D3DXVec3Cross(&m_d3dxvUp, &m_d3dxvLook, &m_d3dxvRight);
//	D3DXVec3Normalize(&m_d3dxvUp, &m_d3dxvUp);
//
//	RegenerateWorldMatrix();
//}
//
//
//void CPlayer::Update(float fTimeElapsed)
//{
//	// 플레이어의 속도 벡터를 중력 벡터와 더한다.
//	// 중력 벡터에 fTimeElapsed를 곱하는 것은 중력을 시간에 비례하도록 적용한다는 의미이다.
//	m_d3dxvVelocity += m_d3dxvGravity * fTimeElapsed;
//
//	// 플레이어의 속도 벡터의 XZ-성분의 크기를 구한다.
//	// 이것이 XZ-평면의 최대 속력보다 크면 속도 벡터의 x와 z-방향 성분을 조정한다.
//	float fLength = sqrtf(m_d3dxvVelocity.x * m_d3dxvVelocity.x + m_d3dxvVelocity.z * m_d3dxvVelocity.z);
//	if (fLength > m_fMaxVelocityXZ)
//	{
//		m_d3dxvVelocity.x *= (m_fMaxVelocityXZ / fLength);
//		m_d3dxvVelocity.z *= (m_fMaxVelocityXZ / fLength);
//	}
//
//	// 플레이어의 속도 벡터의 Y-성분의 크기를 구한다.
//	// 이것이 Y 축 방향의 최대 속력보다 크면 속도 벡터의 y-방향 성분을 조정한다.
//	fLength = sqrtf(m_d3dxvVelocity.y * m_d3dxvVelocity.y);
//	if (fLength > m_fMaxVelocityY) m_d3dxvVelocity.y *= (m_fMaxVelocityY / fLength);
//
//	/*플레이어를 속도 벡터 만큼 이동한다. 속도 벡터에 fTimeElapsed를 곱하는 것은 속도를 시간에 비례하도록 적용한다는 의미이다.*/
//	Move(m_d3dxvVelocity * fTimeElapsed, false);
//
//	// 플레이어의 위치가 변경될 때 추가로 수행할 작업을 수행한다.
//	// 예를 들어, 플레이어의 위치가 변경되었지만 플레이어 객체에는 지형(Terrain)의 정보가 없다.
//	// 플레이어의 새로운 위치가 유효한 위치가 아닐 수도 있고 또는 플레이어의 충돌 검사 등을 수행할 필요가 있다.
//	// 이러한 상황에서 플레이어의 위치를 유효한 위치로 다시 변경할 수 있다.
//	if (m_pPlayerUpdatedContext) OnPlayerUpdated(fTimeElapsed);
//
//	//DWORD nCurrentCameraMode = m_pCamera->GetMode();
//	////플레이어의 위치가 변경되었으므로 카메라의 상태를 갱신한다.
//	//if (nCurrentCameraMode == THIRD_PERSON_CAMERA) m_pCamera->Update(fTimeElapsed);
//	////카메라의 위치가 변경될 때 추가로 수행할 작업을 수행한다. 
//	//if (m_pCameraUpdatedContext) OnCameraUpdated(fTimeElapsed);
//	////카메라가 3인칭 카메라이면 카메라가 변경된 플레이어 위치를 바라보도록 한다.
//	//if (nCurrentCameraMode == THIRD_PERSON_CAMERA) m_pCamera->SetLookAt(m_d3dxvPosition);
//	////카메라의 카메라 변환 행렬을 다시 생성한다.
//	//m_pCamera->RegenerateViewMatrix();
//
//	// 플레이어의 속도 벡터가 마찰력 때문에 감속이 되어야 한다면 감속 벡터를 생성한다.
//	// 속도 벡터의 반대 방향 벡터를 구하고 단위 벡터로 만든다. 마찰 계수를 시간에 비례하도록 하여 마찰력을 구한다.
//	// 단위 벡터에 마찰력을 곱하여 감속 벡터를 구한다. 속도 벡터에 감속 벡터를 더하여 속도 벡터를 줄인다.
//	// 마찰력이 속력보다 크면 속력은 0이 될 것이다.
//	D3DXVECTOR3 d3dxvDeceleration = -m_d3dxvVelocity;
//	D3DXVec3Normalize(&d3dxvDeceleration, &d3dxvDeceleration);
//	fLength = D3DXVec3Length(&m_d3dxvVelocity);
//	float fDeceleration = (m_fFriction * fTimeElapsed);
//	if (fDeceleration > fLength) fDeceleration = fLength;
//	m_d3dxvVelocity += d3dxvDeceleration * fDeceleration;
//}
//
////CCamera *CPlayer::OnChangeCamera(ID3D11Device *pd3dDevice, DWORD nNewCameraMode, DWORD nCurrentCameraMode)
////{
////	CCamera *pNewCamera = NULL;
////	//새로운 카메라의 모드에 따라 카메라를 새로 생성한다.
////	switch (nNewCameraMode)
////	{
////	case THIRD_PERSON_CAMERA:
////		pNewCamera = new CThirdPersonCamera(m_pCamera);
////		break;
////	}
////	
////	if (pNewCamera)
////	{
////		//기존 카메라가 없으면 새로운 카메라를 위한 쉐이더 변수를 생성한다.
////		if (!m_pCamera) pNewCamera->CreateShaderVariables(pd3dDevice);
////		pNewCamera->SetMode(nNewCameraMode);
////		//현재 카메라를 사용하는 플레이어 객체를 설정한다.
////		pNewCamera->SetPlayer(this);
////	}
////
////	if (m_pCamera) delete m_pCamera;
////
////	return(pNewCamera);
////}
//
//void CPlayer::Render(ID3D11DeviceContext *pd3dDeviceContext)
//{
//	if (m_pShader)
//	{
//		m_pShader->UpdateShaderVariables(pd3dDeviceContext, &m_d3dxmtxWorld);
//		m_pShader->Render(pd3dDeviceContext);
//	}
//	if (m_pMesh) m_pMesh->Render(pd3dDeviceContext);
//}
//
//void CPlayer::OnPlayerUpdated(float fTimeElapsed)
//{
//}
//
